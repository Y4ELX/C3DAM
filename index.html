<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Cámara y Visor 3D (Prueba Object URL)</title>
  <style>
    /* Reset y Estilos Base */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      /* Desactivar selección de texto y callouts en móviles */
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ */
      user-select: none;
      -webkit-touch-callout: none; /* iOS Safari */
    }

    html {
        height: -webkit-fill-available; /* Soporte extra para iOS */
        background-color: #000; /* Fondo negro general */
    }

    body {
      height: 100dvh;
      min-height: -webkit-fill-available;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      display: flex;
      flex-direction: column;
      background-color: #000;
      color: #fff;
    }

    /* Contenedor de la interfaz principal (Cámara) */
    #mainInterface {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
    }

    /* Contenedor principal para video y flash */
    .viewport-container {
        position: relative;
        flex-grow: 1;
        overflow: hidden;
        display: flex;
        background-color: #000;
    }

    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      z-index: 1;
    }

    #flashOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: white;
        opacity: 0;
        pointer-events: none;
        z-index: 5;
        display: none;
    }

    @keyframes flashAnimation {
        0% { opacity: 0; }
        50% { opacity: 0.7; }
        100% { opacity: 0; }
    }

    #flashOverlay.flash {
        display: block;
        animation: flashAnimation 0.3s ease-in-out;
    }

    /* Contenedor de controles inferior */
    #controls-container {
      background-color: #000;
      padding: 15px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      flex-shrink: 0;
      z-index: 10;
      position: relative;
    }

    /* Contenedor para botones iniciales */
    #initial-buttons {
        display: flex; /* Alinea botones horizontalmente */
        gap: 15px; /* Espacio entre botones */
        margin-bottom: 10px;
    }


    #progress {
      margin-bottom: 15px;
      font-size: 0.9em;
      color: #ccc;
      text-align: center;
      min-height: 2.5em;
      line-height: 1.4;
    }

    button {
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      font-size: 1em;
      padding: 10px 15px;
      border-radius: 8px;
      background-color: #333; /* Estilo base para botones */
      transition: background-color 0.2s ease;
    }
    button:active {
        background-color: #555;
    }

    #startBtn, #visualizeBtn { /* Botones iniciales */
       padding: 12px 20px;
       font-weight: 500;
    }

    #takeFirstPhoto, #takeSecondPhoto { /* Botones obturador */
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.9);
      border: 4px solid #fff;
      padding: 0;
      margin: 10px 0;
      position: relative;
    }
    #takeFirstPhoto:active, #takeSecondPhoto:active {
        background-color: rgba(200, 200, 200, 0.9);
    }

    #canvas { display: none; }
    #photoPreview { display: none; }
    #fileInput { display: none; } /* Input de archivo oculto */

    /* --- Estilos del Modal (Resultado Cámara) --- */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100dvh;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      padding: 15px;
    }

    .modal-content {
      background-color: #282828;
      color: #fff;
      margin: auto;
      padding: 25px;
      width: auto;
      max-width: 90%;
      max-height: 90dvh;
      position: relative;
      border-radius: 12px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.5);
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .modal-content img {
      display: block;
      max-width: 100%;
      max-height: calc(90dvh - 150px);
      height: auto;
      margin-bottom: 20px;
      border-radius: 6px;
    }

    .close-btn { /* Botón cerrar para ambos modales/visores */
      color: #ccc;
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 30px;
      font-weight: bold;
      cursor: pointer;
      line-height: 1;
      z-index: 10; /* Encima de la imagen */
      padding: 5px; /* Área de toque más grande */
      background-color: rgba(0, 0, 0, 0.3); /* Fondo sutil */
      border-radius: 50%;
    }
    .close-btn:hover,
    .close-btn:focus {
      color: #fff;
      background-color: rgba(0, 0, 0, 0.6);
    }

    #saveBtn {
      background-color: #007AFF;
      color: white;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1em;
      font-weight: bold;
      margin-top: 10px;
    }
    #saveBtn:hover { background-color: #005ecb; }

    /* --- Estilos del Visor de Imágenes --- */
    #imageViewer {
        display: none; /* Oculto por defecto */
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100dvh;
        background-color: #000;
        z-index: 2000; /* Encima de todo lo demás */
        /* Forzar gestos de pinch/pan en este contenedor */
        touch-action: none;
    }

    #splitViewContainer {
        position: relative; /* Contenedor para imágenes absolutas */
        width: 100%;
        height: 100%;
        overflow: hidden; /* Clave para el efecto zoom/pan */
        display: flex; /* Aunque usemos absoluto, flex ayuda inicialmente */
    }

    #leftImage, #rightImage {
        position: absolute;
        top: 0;
        height: 100%; /* Ocupa toda la altura */
        width: 50%; /* Cada una ocupa la mitad del ancho */
        object-fit: cover; /* Cubre su 50% de espacio */
        /* Origen de la transformación para zoom centrado */
        transform-origin: center center;
        /* Transición suave para transformaciones (opcional) */
        /* transition: transform 0.1s ease-out; */
        will-change: transform; /* Optimización para animación */
        background-color: #111; /* Fondo oscuro por si la imagen no carga */
    }

    #leftImage {
        left: 0;
    }

    #rightImage {
        left: 50%; /* Empieza en la mitad derecha */
    }

    /* Botón de cerrar específico del visor */
    #closeViewerBtn {
        /* Usa la clase genérica .close-btn */
    }
  </style>
</head>
<body>

<div id="mainInterface">
    <div class="viewport-container">
        <video id="video" autoplay muted playsinline></video>
        <div id="flashOverlay"></div>
    </div>
    <canvas id="canvas"></canvas> <div id="controls-container">
      <div id="progress"></div>
      <div id="initial-buttons">
          <button id="startBtn">Iniciar Cámara</button>
          <button id="visualizeBtn">Visualizar Fotos</button>
      </div>
      <button id="takeFirstPhoto" style="display:none;"></button>
      <button id="takeSecondPhoto" style="display:none;"></button>
    </div>
</div>

<input type="file" id="fileInput" accept="image/*">

<div id="resultModal" class="modal">
  <div class="modal-content">
    <span id="closeResultModalBtn" class="close-btn">&times;</span>
    <img id="resultImage" src="" alt="Foto 3D Generada">
    <button id="saveBtn">Guardar Foto</button>
  </div>
</div>

<div id="imageViewer">
    <div id="splitViewContainer">
        <img id="leftImage" src="" alt="Mitad Izquierda">
        <img id="rightImage" src="" alt="Mitad Derecha">
    </div>
    <span id="closeViewerBtn" class="close-btn">&times;</span>
</div>


<script>
  let firstImageData = null;
  let stream = null;

  // --- Elementos DOM ---
  const mainInterface = document.getElementById('mainInterface');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas'); // Canvas para tomar fotos
  const progress = document.getElementById('progress');
  const startBtn = document.getElementById('startBtn');
  const visualizeBtn = document.getElementById('visualizeBtn');
  const initialButtonsContainer = document.getElementById('initial-buttons');
  const takeFirstPhotoBtn = document.getElementById('takeFirstPhoto');
  const takeSecondPhotoBtn = document.getElementById('takeSecondPhoto');
  const controlsContainer = document.getElementById('controls-container');
  const flashOverlay = document.getElementById('flashOverlay');
  const fileInput = document.getElementById('fileInput');

  // Modal Resultado Cámara
  const resultModal = document.getElementById('resultModal');
  const resultImage = document.getElementById('resultImage');
  const closeResultModalBtn = document.getElementById('closeResultModalBtn');
  const saveBtn = document.getElementById('saveBtn');

  // Visor de Imágenes
  const imageViewer = document.getElementById('imageViewer');
  const splitViewContainer = document.getElementById('splitViewContainer');
  const leftImage = document.getElementById('leftImage');
  const rightImage = document.getElementById('rightImage');
  const closeViewerBtn = document.getElementById('closeViewerBtn');

  // --- Estado de Zoom/Pan del Visor ---
  let currentScale = 1;
  let currentTranslateX = 0;
  let currentTranslateY = 0;
  let isPanning = false;
  let isZooming = false;
  let startX, startY, initialPinchDistance;
  let initialTranslateX = 0, initialTranslateY = 0;

  // --- Gestión de Object URLs ---
  let objectURLsToRevoke = [];

  function revokePreviousObjectURLs() {
    if (objectURLsToRevoke.length > 0) {
        console.log("Revocando", objectURLsToRevoke.length, "Object URLs anteriores.");
        objectURLsToRevoke.forEach(url => {
            // console.log("Revocando:", url.substring(0, 100)); // Log detallado opcional
            URL.revokeObjectURL(url);
        });
        objectURLsToRevoke = []; // Limpiar la lista
    }
  }


  // --- Funciones Cámara ---
  function triggerFlash() {
      flashOverlay.style.display = 'block';
      flashOverlay.classList.add('flash');
  }

  flashOverlay.addEventListener('animationend', () => {
      flashOverlay.classList.remove('flash');
      flashOverlay.style.display = 'none';
  });

  function startCamera() {
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(mediaStream => {
        stream = mediaStream;
        video.srcObject = stream;
        video.style.display = 'block';
        initialButtonsContainer.style.display = 'none';
        takeFirstPhotoBtn.style.display = 'block';
        takeSecondPhotoBtn.style.display = 'none';
        controlsContainer.style.display = 'flex';
        progress.innerText = "Toma la primera foto";
      })
      .catch(err => {
        console.error('Error al acceder a la cámara:', err);
        alert('No se pudo acceder a la cámara: ' + err.message);
        resetUI();
      });
  }

  function stopCamera() {
      if (stream) {
          stream.getTracks().forEach(track => track.stop());
          stream = null;
          video.srcObject = null;
      }
  }

  function takePhoto() {
    const ctx = canvas.getContext('2d');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/jpeg');
  }

  function requestPermissionAndStart() {
    startCamera();
  }

  // --- Modificado resetUI para revocar URLs ---
  function resetUI() {
      stopCamera();
      revokePreviousObjectURLs(); // Revocar URLs al resetear
      video.style.display = 'block';
      initialButtonsContainer.style.display = 'flex';
      takeFirstPhotoBtn.style.display = 'none';
      takeSecondPhotoBtn.style.display = 'none';
      progress.innerText = '';
      resultModal.style.display = 'none';
      imageViewer.style.display = 'none'; // Ocultar visor
      mainInterface.style.display = 'flex'; // Mostrar interfaz principal
      controlsContainer.style.display = 'flex';
      firstImageData = null;
      flashOverlay.style.display = 'none';
      flashOverlay.classList.remove('flash');
      resetViewerState(); // Resetear estado del visor (zoom/pan/src)
  }

  // --- Funciones Visor de Imágenes ---

  function resetViewerState() {
    currentScale = 1;
    currentTranslateX = 0;
    currentTranslateY = 0;
    applyTransform(); // Aplica el estado reseteado
    // Limpiar imágenes del visor (src se limpia en resetUI al revocar)
    // leftImage.removeAttribute('src');
    // rightImage.removeAttribute('src');
    fileInput.value = null; // Permitir seleccionar el mismo archivo de nuevo
  }

  function applyTransform() {
      const transformValue = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`;
      leftImage.style.transform = transformValue;
      rightImage.style.transform = transformValue;
  }

  // --- INICIO: VERSIÓN DE PRUEBA handleFileSelect (Object URL / toBlob) ---
  function handleFileSelect(event) {
    console.log("handleFileSelect llamado (Prueba Object URL)");
    const file = event.target.files[0];
    if (!file || !file.type.startsWith('image/')) {
        alert('Por favor, selecciona un archivo de imagen.');
        resetUI(); return;
    }
    console.log("Archivo seleccionado:", file.name, file.type);

    // Revoke any URLs created from the previous image viewing session
    revokePreviousObjectURLs();

    // Crear un Object URL para el *archivo original* seleccionado
    let originalFileURL = null;
    try {
        originalFileURL = URL.createObjectURL(file);
        objectURLsToRevoke.push(originalFileURL); // Add to list for future cleanup
        console.log("Original File Object URL creado:", originalFileURL.substring(0, 100));
    } catch (error) {
        console.error("Error creando Object URL para el archivo original:", error);
        alert("Error al crear URL para el archivo.");
        resetUI();
        return;
    }


    const img = new Image();
    img.onload = function() {
        console.log("Image onload. Dimensiones:", img.naturalWidth, "x", img.naturalHeight);
        try {
            // --- PRUEBA: Dibuja la imagen COMPLETA en UN canvas ---
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            if (!tempCtx) throw new Error("No se pudo obtener contexto 2D");

            if (img.naturalWidth <= 0 || img.naturalHeight <= 0) {
                throw new Error("Dimensiones de imagen inválidas: " + img.naturalWidth + "x" + img.naturalHeight);
            }

            tempCanvas.width = img.naturalWidth;
            tempCanvas.height = img.naturalHeight;

            console.log("Dibujando imagen completa en canvas temporal...");
            tempCtx.drawImage(img, 0, 0); // Dibuja la imagen completa
            console.log("Dibujo completo.");

            // --- CAMBIO: Convertir canvas a Blob (asíncrono) ---
            console.log("Llamando a canvas.toBlob() para generar JPEG...");
            tempCanvas.toBlob(function(blob) {
                // --- Este código se ejecuta DESPUÉS de que toBlob termine ---
                if (!blob) {
                    console.error("canvas.toBlob() falló - no se generó blob.");
                    alert("Error: No se pudo convertir el canvas a blob.");
                    // No llamar a resetUI aquí directamente podría ser mejor
                    // para evitar revocar la URL original si aún se necesita.
                    // Quizás solo ocultar el visor si ya estaba visible.
                    imageViewer.style.display = 'none';
                    mainInterface.style.display = 'flex';
                    return;
                }
                console.log("canvas.toBlob() exitoso. Tipo de Blob:", blob.type, "Tamaño:", blob.size);

                // --- CAMBIO: Crear Object URL desde el Blob del canvas ---
                let canvasBlobURL = null;
                 try {
                    canvasBlobURL = URL.createObjectURL(blob);
                    objectURLsToRevoke.push(canvasBlobURL); // Add to list for future cleanup
                    console.log("Canvas Blob Object URL creado:", canvasBlobURL.substring(0, 100));
                 } catch(error) {
                     console.error("Error creando Object URL desde el blob del canvas:", error);
                     alert("Error al crear URL para la imagen procesada.");
                     // No llamar a resetUI aquí
                     imageViewer.style.display = 'none';
                     mainInterface.style.display = 'flex';
                     return;
                 }


                // --- Asigna ESTE Object URL a AMBAS mitades ---
                console.log("Asignando Object URL del canvas a las imágenes del visor...");
                leftImage.src = canvasBlobURL;
                rightImage.src = canvasBlobURL; // Usar la misma URL para la prueba

                // --- Mostrar Visor ---
                console.log("Mostrando el visor con imagen de prueba (Object URL)...");
                resetViewerState(); // Aplica transformaciones iniciales (scale 1, translate 0)
                imageViewer.style.display = 'block';
                mainInterface.style.display = 'none';

            }, 'image/jpeg', 0.8); // Especificar tipo y calidad para toBlob

        } catch(error) {
             console.error("Error durante la prueba de canvas único (Object URL):", error);
             alert("Error al procesar la imagen (prueba Object URL): " + error.message);
             resetUI(); // Aquí sí reseteamos porque falló antes del paso asíncrono
        }
        // No poner código aquí que dependa del resultado de toBlob
    } // Fin img.onload

    img.onerror = function(e) {
        console.error("Image onerror al cargar desde:", originalFileURL ? originalFileURL.substring(0,100) : "URL inválida");
        alert('Error: No se pudo cargar la imagen fuente seleccionada desde Object URL.');
        resetUI(); // Llama a resetUI que también revocará la URL fallida si existe
    }
    // Asigna la URL del *archivo original* al src de la imagen temporal
    console.log("Asignando Object URL del archivo original a img.src");
    img.src = originalFileURL; // Cargar imagen desde el Object URL del archivo
}
  // --- FIN: VERSIÓN DE PRUEBA handleFileSelect (Object URL / toBlob) ---


  // --- Manejo Táctil del Visor (Sin cambios respecto a la versión anterior) ---
  function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
  }

  function getMidpoint(touches) {
      return {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
      };
  }

  splitViewContainer.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touches = e.touches;
      if (touches.length === 1) {
          isPanning = true;
          isZooming = false;
          startX = touches[0].clientX;
          startY = touches[0].clientY;
          initialTranslateX = currentTranslateX;
          initialTranslateY = currentTranslateY;
      } else if (touches.length === 2) {
          isZooming = true;
          isPanning = false;
          initialPinchDistance = getDistance(touches);
          initialTranslateX = currentTranslateX;
          initialTranslateY = currentTranslateY;
          // Guardamos la escala inicial para calcular el ratio relativo
          // startScale = currentScale; // Necesitaríamos esto para un cálculo preciso del ratio
      }
  }, { passive: false });

  splitViewContainer.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touches = e.touches;
      if (isPanning && touches.length === 1) {
          const dx = touches[0].clientX - startX;
          const dy = touches[0].clientY - startY;
          currentTranslateX = initialTranslateX + dx;
          currentTranslateY = initialTranslateY + dy;
          applyTransform();
      } else if (isZooming && touches.length === 2) {
          const currentDistance = getDistance(touches);
          if (initialPinchDistance <= 0) return;
          const scaleRatio = currentDistance / initialPinchDistance;

          // Aplicar ratio a la escala actual (puede causar aceleración, ver nota anterior)
          let potentialNewScale = currentScale * scaleRatio;

          // Clamp scale (e.g., between 1x and 10x)
          potentialNewScale = Math.max(1, Math.min(potentialNewScale, 10));

          // Ajuste de traslación para zoom desde el centro (omitido por simplicidad)

          currentScale = potentialNewScale;

          // Actualizar initialPinchDistance para el siguiente evento move
          initialPinchDistance = currentDistance; // Mantiene la lógica anterior

          applyTransform();
      }
  }, { passive: false });

  splitViewContainer.addEventListener('touchend', (e) => {
      const touches = e.touches;
      if (touches.length < 2) {
          isZooming = false;
      }
      if (touches.length < 1) {
          isPanning = false;
      } else if (touches.length === 1) {
           if(!isPanning) {
                isPanning = true;
                isZooming = false;
                startX = touches[0].clientX;
                startY = touches[0].clientY;
                initialTranslateX = currentTranslateX;
                initialTranslateY = currentTranslateY;
           }
      }
      if (!isZooming) {
          initialPinchDistance = 0;
      }
  });


  // --- Event Listeners Botones (Sin cambios) ---
  startBtn.onclick = requestPermissionAndStart;
  visualizeBtn.onclick = () => fileInput.click();
  fileInput.onchange = handleFileSelect; // Llama a la versión de prueba Object URL
  closeViewerBtn.onclick = resetUI; // Llama a resetUI que revoca URLs

  takeFirstPhotoBtn.onclick = () => {
    triggerFlash();
    firstImageData = takePhoto();
    progress.innerText = "¡OK! Ahora mueve el móvil ~5cm a la derecha y toma la segunda foto.";
    takeFirstPhotoBtn.style.display = 'none';
    takeSecondPhotoBtn.style.display = 'block';
  };

  takeSecondPhotoBtn.onclick = () => {
    triggerFlash();
    const secondImageData = takePhoto();
    progress.innerText = "Procesando...";

    const img1 = new Image();
    const img2 = new Image();
    img1.onload = () => {
      img2.onload = () => {
        const combinedCanvas = document.createElement('canvas');
        const combinedCtx = combinedCanvas.getContext('2d');
        combinedCanvas.width = img1.width + img2.width;
        combinedCanvas.height = Math.max(img1.height, img2.height);
        combinedCtx.drawImage(img1, 0, 0);
        combinedCtx.drawImage(img2, img1.width, 0);
        const combinedImageURL = combinedCanvas.toDataURL('image/jpeg');

        resultImage.src = combinedImageURL;
        resultModal.style.display = 'flex';
        progress.innerText = '';
        takeSecondPhotoBtn.style.display = 'none';
      };
      img2.src = secondImageData;
    };
    img1.src = firstImageData;
  };

  // Modificado para llamar a resetUI
  closeResultModalBtn.onclick = () => {
    resetUI();
  };

  // Modificado para llamar a resetUI
  window.onclick = (event) => {
    if (event.target == resultModal) {
       resetUI();
    }
  };

  saveBtn.onclick = () => {
    const link = document.createElement('a');
    link.href = resultImage.src;
    link.download = 'foto-3d-captura.jpg';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Inicializar UI al cargar
  resetUI();

</script>

</body>
</html>