<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><polygon points="15,30 50,10 85,30 50,50" fill="%23ccc"/><polygon points="15,30 15,70 50,90 50,50" fill="%23aaa"/><polygon points="50,50 50,90 85,70 85,30" fill="%23888"/><circle cx="50" cy="60" r="18" fill="%23555"/><circle cx="50" cy="60" r="10" fill="%23333"/><rect x="65" y="22" width="10" height="5" fill="%23666" transform="skewY(-10)"/></svg>'>
  <title>Cámara y Visor 3D (Fullscreen Simulado)</title>
  <style>
    /* Reset y Estilos Base Modernizados */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  -webkit-tap-highlight-color: transparent; /* Evita el resaltado azul en taps */
  -webkit-user-select: none; /* Deshabilita selección */
  user-select: none;
  -webkit-touch-callout: none; /* Deshabilita menú contextual en iOS */
}

html {
  height: -webkit-fill-available; /* Para iOS Safari */
  background-color: #000;
}

body {
  height: 100dvh; /* Altura dinámica del viewport */
  min-height: -webkit-fill-available;
  overflow: hidden; /* Previene scroll */
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; /* Fuente estándar de iOS/macOS y fallback */
  display: flex;
  flex-direction: column;
  background-color: #000; /* Fondo negro principal */
  color: #fff; /* Texto blanco por defecto */
  -webkit-font-smoothing: antialiased; /* Mejora renderizado de fuentes */
  -moz-osx-font-smoothing: grayscale;
}

/* --- Estilos Cámara --- */
#mainInterface {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  position: relative; /* Para posicionar controles si es necesario */
}

.viewport-container {
  position: relative;
  flex-grow: 1; /* Ocupa el espacio disponible */
  overflow: hidden;
  display: flex;
  background-color: #000; /* Fondo negro si el video no carga */
}

#video {
  width: 100%;
  height: 100%;
  object-fit: cover; /* Cubre el contenedor manteniendo aspecto */
  display: block;
  z-index: 1;
}

/* Overlay de Flash (sin cambios significativos, ya es funcional) */
#flashOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: white;
  opacity: 0;
  pointer-events: none;
  z-index: 5;
  display: none; /* Oculto hasta que se activa */
}
@keyframes flashAnimation {
  0% { opacity: 0; }
  50% { opacity: 0.8; } /* Un poco más visible */
  100% { opacity: 0; }
}
#flashOverlay.flash {
  display: block;
  animation: flashAnimation 0.25s ease-in-out; /* Animación más rápida */
}

/* Contenedor de Controles (Estilo iOS Translúcido) */
#controls-container {
  background-color: rgba(0, 0, 0, 0.6); /* Fondo negro semitransparente */
  backdrop-filter: blur(10px); /* Efecto blur tipo iOS */
  -webkit-backdrop-filter: blur(10px); /* Para Safari */
  padding: 20px; /* Más espaciado interno */
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  flex-shrink: 0; /* No se encoge */
  z-index: 10;
  position: relative; /* O absolute si prefieres superponerlo */
  /* Si usas position: absolute; bottom: 0; left: 0; */
  /* necesitarás ajustar el padding-bottom de #mainInterface o el height de .viewport-container */
}

#initial-buttons {
  display: flex;
  gap: 15px; /* Espacio entre botones iniciales */
  margin-bottom: 20px; /* Más espacio antes del progreso/shutter */
}

#progress {
  margin-bottom: 15px;
  font-size: 0.95em; /* Ligeramente más grande */
  color: #d1d1d6; /* Gris claro estándar de iOS (modo oscuro) */
  text-align: center;
  min-height: 2.5em;
  line-height: 1.4;
  font-weight: 400;
}

/* Estilo Base de Botones */
button {
  background: none;
  border: none;
  color: #fff;
  cursor: pointer;
  font-size: 1em;
  padding: 12px 20px; /* Padding base */
  border-radius: 10px; /* Bordes redondeados */
  background-color: rgba(60, 60, 67, 0.8); /* Gris oscuro translúcido iOS */
  transition: background-color 0.2s ease, transform 0.1s ease; /* Transiciones suaves */
  font-weight: 500; /* Peso medio */
}

button:active {
  background-color: rgba(80, 80, 97, 0.9); /* Oscurece un poco al presionar */
  transform: scale(0.97); /* Efecto de presión sutil */
}

/* Botones de Acción Principal (Azul iOS) */
#startBtn, #visualizeBtn, #saveBtn {
  background-color: #0A84FF; /* Azul vibrante de iOS */
  color: white;
  font-weight: 600; /* Un poco más bold */
  padding: 12px 25px;
}
#startBtn:active, #visualizeBtn:active, #saveBtn:active {
  background-color: #0060df; /* Azul más oscuro al presionar */
}

/* Botón de Captura (Shutter) */
#takeFirstPhoto, #takeSecondPhoto {
  width: 70px;
  height: 70px;
  border-radius: 50%; /* Círculo perfecto */
  background-color: #fff; /* Blanco sólido */
  border: 5px solid #fff; /* Borde blanco grueso */
  padding: 0; /* Sin padding interno */
  margin: 10px 0;
  position: relative;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* Sombra suave */
  /* No necesita color de texto */
}
#takeFirstPhoto:active, #takeSecondPhoto:active {
  background-color: #e5e5e5; /* Gris claro al presionar */
  border-color: #e5e5e5;
  transform: scale(0.95); /* Encoge ligeramente */
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2); /* Sombra reducida */
}

/* Elementos ocultos */
#canvas, #photoPreview, #fileInput { display: none; }

/* --- Estilos Modal Resultado (Estilo Alerta/Modal iOS) --- */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100dvh;
  overflow: auto; /* Permite scroll si el contenido es muy grande */
  background-color: rgba(0, 0, 0, 0.65); /* Fondo oscuro más pronunciado */
  justify-content: center;
  align-items: center;
  padding: 15px;
  /* Animación opcional para aparecer */
  /* opacity: 0; */
  /* transition: opacity 0.3s ease; */
}
/* .modal.show { display: flex; opacity: 1; } */

.modal-content {
  background-color: #2c2c2e; /* Gris muy oscuro iOS (Dark Mode) */
  color: #fff;
  margin: auto;
  padding: 25px; /* Padding generoso */
  width: auto;
  max-width: 90%;
  max-height: 90dvh; /* Limita altura */
  position: relative;
  border-radius: 14px; /* Bordes más redondeados tipo iOS */
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); /* Sombra más pronunciada */
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.modal-content img {
  display: block;
  max-width: 100%;
  max-height: calc(90dvh - 160px); /* Ajusta según padding y botones */
  height: auto;
  margin-bottom: 25px; /* Más espacio bajo la imagen */
  border-radius: 8px; /* Redondeo suave para la imagen */
}

/* Botón Cerrar (Estilo iOS) */
.close-btn {
  color: #8A8A8E; /* Gris neutro iOS */
  position: absolute;
  top: 12px; /* Ajuste fino */
  right: 12px;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background-color: rgba(118, 118, 128, 0.24); /* Fondo gris translúcido */
  font-size: 16px; /* Tamaño de la 'x' */
  font-weight: 600;
  line-height: 30px; /* Centrado vertical */
  text-align: center;
  cursor: pointer;
  z-index: 20;
  transition: background-color 0.2s ease, color 0.2s ease;
}
.close-btn:hover, .close-btn:focus {
  background-color: rgba(118, 118, 128, 0.4); /* Más opaco al pasar el ratón */
  color: #fff; /* Texto blanco */
}
/* Botón Guardar ya hereda estilo de #saveBtn */

/* --- Estilos del Visor de Imágenes --- */
#imageViewer {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100dvh;
  background-color: #000; /* Fondo negro sólido */
  z-index: 2000;
  touch-action: none; /* Previene acciones default del navegador en touch */
}

#splitViewContainer {
  display: flex;
  width: 100%;
  height: 100%;
}

.image-half-container {
  width: 50%;
  height: 100%;
  overflow: hidden; /* Esconde partes de la imagen que se salen */
  position: relative;
}

#leftImage, #rightImage {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover; /* Cubre el contenedor */
  transform-origin: center center; /* Zoom/pan desde el centro */
  will-change: transform; /* Optimiza la animación de transformación */
  background-color: #111; /* Fondo si la imagen tarda */
}

/* Botones dentro del visor (Cerrar usa .close-btn) */
#closeViewerBtn { /* Hereda .close-btn, pero posición puede necesitar ajuste si no es la misma */
    top: 20px;
    right: 20px;
}

.viewer-button { /* Estilo para otros botones del visor, como #fullscreenBtn */
  position: absolute;
  z-index: 15;
  background-color: rgba(60, 60, 67, 0.8); /* Mismo gris que botones normales */
  border: none;
  color: #fff;
  padding: 10px 15px;
  border-radius: 8px;
  font-size: 0.9em;
  cursor: pointer;
  transition: background-color 0.2s ease;
}
.viewer-button:hover {
  background-color: rgba(80, 80, 97, 0.9);
}
#fullscreenBtn {
  bottom: 25px; /* Posicionamiento */
  left: 20px;
}

/* --- Clase para Simular Fullscreen (sin cambios, es funcional) --- */
.fullscreen-simulated {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  width: 100vw !important;
  height: 100dvh !important;
  z-index: 5000 !important;
  background-color: #000 !important;
}
  </style>
</head>
<body>

<div id="mainInterface">
    <div class="viewport-container">
        <video id="video" autoplay muted playsinline></video>
        <div id="flashOverlay"></div>
    </div>
    <canvas id="canvas"></canvas>

    <div id="controls-container">
      <div id="progress"></div>
      <div id="initial-buttons">
          <button id="startBtn">Iniciar Cámara</button>
          <button id="visualizeBtn">Visualizar Fotos</button>
      </div>
      <button id="takeFirstPhoto" style="display:none;"></button>
      <button id="takeSecondPhoto" style="display:none;"></button>
    </div>
</div>

<input type="file" id="fileInput" accept="image/*">

<div id="resultModal" class="modal">
  <div class="modal-content">
    <span id="closeResultModalBtn" class="close-btn">&times;</span>
    <img id="resultImage" src="" alt="Foto 3D Generada">
    <button id="saveBtn">Guardar Foto</button>
  </div>
</div>

<div id="imageViewer">
    <div id="splitViewContainer">
        <div id="leftContainer" class="image-half-container">
            <img id="leftImage" src="" alt="Mitad Izquierda">
        </div>
        <div id="rightContainer" class="image-half-container">
            <img id="rightImage" src="" alt="Mitad Derecha">
        </div>
    </div>
    <span id="closeViewerBtn" class="close-btn">&times;</span>
    <button id="fullscreenBtn" class="viewer-button">Ampliar</button> </div>


<script>
  let firstImageData = null;
  let stream = null;

  // --- Elementos DOM ---
  const mainInterface = document.getElementById('mainInterface');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const progress = document.getElementById('progress');
  const startBtn = document.getElementById('startBtn');
  const visualizeBtn = document.getElementById('visualizeBtn');
  const initialButtonsContainer = document.getElementById('initial-buttons');
  const takeFirstPhotoBtn = document.getElementById('takeFirstPhoto');
  const takeSecondPhotoBtn = document.getElementById('takeSecondPhoto');
  const controlsContainer = document.getElementById('controls-container');
  const flashOverlay = document.getElementById('flashOverlay');
  const fileInput = document.getElementById('fileInput');
  const resultModal = document.getElementById('resultModal');
  const resultImage = document.getElementById('resultImage');
  const closeResultModalBtn = document.getElementById('closeResultModalBtn');
  const saveBtn = document.getElementById('saveBtn');
  const imageViewer = document.getElementById('imageViewer');
  const splitViewContainer = document.getElementById('splitViewContainer');
  const leftImage = document.getElementById('leftImage');
  const rightImage = document.getElementById('rightImage');
  const closeViewerBtn = document.getElementById('closeViewerBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');

  // --- Estado de Zoom/Pan ---
  let currentScale = 1; let currentTranslateX = 0; let currentTranslateY = 0;
  let isPanning = false; let isZooming = false;
  let startX, startY, initialPinchDistance;
  let initialTranslateX = 0, initialTranslateY = 0;

  // --- Gestión de Object URLs ---
  let objectURLsToRevoke = [];
  function revokePreviousObjectURLs() {
    if (objectURLsToRevoke.length > 0) {
        console.log("Revocando", objectURLsToRevoke.length, "Object URLs anteriores.");
        objectURLsToRevoke.forEach(url => { URL.revokeObjectURL(url); });
        objectURLsToRevoke = [];
    }
  }

  // --- Funciones Cámara ---
  function triggerFlash() { flashOverlay.style.display = 'block'; flashOverlay.classList.add('flash'); }
  flashOverlay.addEventListener('animationend', () => { flashOverlay.classList.remove('flash'); flashOverlay.style.display = 'none'; });
  function startCamera() {
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(mediaStream => { stream = mediaStream; video.srcObject = stream; video.style.display = 'block'; initialButtonsContainer.style.display = 'none'; takeFirstPhotoBtn.style.display = 'block'; takeSecondPhotoBtn.style.display = 'none'; controlsContainer.style.display = 'flex'; progress.innerText = "Toma la primera foto"; })
      .catch(err => { console.error('Error cámara:', err); alert('No se pudo acceder a la cámara: ' + err.message); resetUI(); });
  }
  function stopCamera() { if (stream) { stream.getTracks().forEach(track => track.stop()); stream = null; video.srcObject = null; } }
  function takePhoto() { const ctx = canvas.getContext('2d'); canvas.width = video.videoWidth; canvas.height = video.videoHeight; ctx.drawImage(video, 0, 0, canvas.width, canvas.height); return canvas.toDataURL('image/jpeg'); }
  function requestPermissionAndStart() { startCamera(); }

  // --- Reset UI ---
  function resetUI() {
      stopCamera(); revokePreviousObjectURLs(); video.style.display = 'block'; initialButtonsContainer.style.display = 'flex';
      takeFirstPhotoBtn.style.display = 'none'; takeSecondPhotoBtn.style.display = 'none'; progress.innerText = ''; resultModal.style.display = 'none';
      imageViewer.style.display = 'none'; mainInterface.style.display = 'flex'; controlsContainer.style.display = 'flex'; firstImageData = null;
      flashOverlay.style.display = 'none'; flashOverlay.classList.remove('flash');
      // Asegurarse de quitar la clase simulada y resetear botón
      imageViewer.classList.remove('fullscreen-simulated');
      fullscreenBtn.textContent = "Ampliar";
      resetViewerState();
  }

  // --- Funciones Visor ---
  function resetViewerState() { currentScale = 1; currentTranslateX = 0; currentTranslateY = 0; applyTransform(); fileInput.value = null; }
  function applyTransform() { const tfm = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`; leftImage.style.transform = tfm; rightImage.style.transform = tfm; }
  function canvasToBlob(canvas, mimeType = 'image/jpeg', quality = 0.85) { return new Promise((resolve, reject) => { if (!canvas.toBlob) { reject(new Error("Canvas.toBlob() no soportado")); return; } canvas.toBlob(blob => { if (blob) { resolve(blob); } else { reject(new Error("canvas.toBlob() falló")); } }, mimeType, quality); }); }
  async function handleFileSelect(event) {
    console.log("handleFileSelect llamado (Split con Object URL)");
    const file = event.target.files[0]; if (!file || !file.type.startsWith('image/')) { alert('Selecciona imagen.'); resetUI(); return; }
    console.log("Archivo:", file.name); revokePreviousObjectURLs(); let originalFileURL = null;
    try { originalFileURL = URL.createObjectURL(file); objectURLsToRevoke.push(originalFileURL); console.log("Original URL creado"); } catch (error) { console.error("Error URL original:", error); alert("Error URL archivo."); resetUI(); return; }
    const img = new Image(); img.onload = async () => { console.log("Img onload D:", img.naturalWidth, "x", img.naturalHeight); if (img.naturalWidth < 2) { alert("Imagen muy estrecha."); resetUI(); return; } try { const canvasLeft = document.createElement('canvas'); const ctxLeft = canvasLeft.getContext('2d'); const leftWidth = Math.floor(img.naturalWidth / 2); const height = img.naturalHeight; canvasLeft.width = leftWidth; canvasLeft.height = height; ctxLeft.drawImage(img, 0, 0, leftWidth, height, 0, 0, leftWidth, height); const canvasRight = document.createElement('canvas'); const ctxRight = canvasRight.getContext('2d'); const rightWidth = img.naturalWidth - leftWidth; const sourceXRight = leftWidth; canvasRight.width = rightWidth; canvasRight.height = height; ctxRight.drawImage(img, sourceXRight, 0, rightWidth, height, 0, 0, rightWidth, height); console.log("Dibujo Mitades OK"); const [blobLeft, blobRight] = await Promise.all([ canvasToBlob(canvasLeft), canvasToBlob(canvasRight) ]); console.log("Blobs OK"); let leftBlobURL = null; let rightBlobURL = null; try { leftBlobURL = URL.createObjectURL(blobLeft); objectURLsToRevoke.push(leftBlobURL); rightBlobURL = URL.createObjectURL(blobRight); objectURLsToRevoke.push(rightBlobURL); console.log("Blob URLs OK"); } catch (error) { console.error("Error URL Blobs:", error); alert("Error URL proc."); resetUI(); return; } leftImage.src = leftBlobURL; rightImage.src = rightBlobURL; console.log("Mostrando visor..."); resetViewerState(); imageViewer.style.display = 'block'; mainInterface.style.display = 'none'; } catch (error) { console.error("Error división:", error); alert("Error proc img: " + error.message); resetUI(); } }; img.onerror = function(e) { console.error("Image onerror:", originalFileURL); alert('Error carga img fuente.'); resetUI(); }; console.log("Asignando URL original a img.src"); img.src = originalFileURL;
  }

  // --- Manejo Táctil Visor (Listeners en imageViewer) ---
  function getDistance(touches) { if (touches.length < 2) return 0; const dx = touches[0].clientX - touches[1].clientX; const dy = touches[0].clientY - touches[1].clientY; return Math.sqrt(dx * dx + dy * dy); }
  function getMidpoint(touches) { if (touches.length < 2) return { x: 0, y: 0}; return { x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2 }; }
  imageViewer.addEventListener('touchstart', (e) => { e.preventDefault(); const touches = e.touches; if (touches.length === 1) { isPanning = true; isZooming = false; startX = touches[0].clientX; startY = touches[0].clientY; initialTranslateX = currentTranslateX; initialTranslateY = currentTranslateY; } else if (touches.length >= 2) { isZooming = true; isPanning = false; initialPinchDistance = getDistance(touches); initialTranslateX = currentTranslateX; initialTranslateY = currentTranslateY; } }, { passive: false });
  imageViewer.addEventListener('touchmove', (e) => { e.preventDefault(); const touches = e.touches; if (isPanning && touches.length === 1) { const dx = touches[0].clientX - startX; const dy = touches[0].clientY - startY; currentTranslateX = initialTranslateX + dx; currentTranslateY = initialTranslateY + dy; applyTransform(); } else if (isZooming && touches.length >= 2) { const currentDistance = getDistance(touches); if (initialPinchDistance <= 0) { initialPinchDistance = currentDistance; if (initialPinchDistance <= 0) return; } const scaleRatio = currentDistance / initialPinchDistance; let potentialNewScale = currentScale * scaleRatio; potentialNewScale = Math.max(1, Math.min(potentialNewScale, 10)); currentScale = potentialNewScale; initialPinchDistance = currentDistance; applyTransform(); } }, { passive: false });
  imageViewer.addEventListener('touchend', (e) => { const touches = e.touches; if (touches.length < 2) { isZooming = false; } if (touches.length < 1) { isPanning = false; } else if (touches.length === 1) { if (!isPanning) { isPanning = true; isZooming = false; startX = touches[0].clientX; startY = touches[0].clientY; initialTranslateX = currentTranslateX; initialTranslateY = currentTranslateY; } } if (!isZooming) { initialPinchDistance = 0; } });

  // --- Event Listeners Botones ---
  startBtn.onclick = requestPermissionAndStart;
  visualizeBtn.onclick = () => fileInput.click();
  fileInput.onchange = handleFileSelect;
  closeViewerBtn.onclick = resetUI;
  takeFirstPhotoBtn.onclick = () => { triggerFlash(); firstImageData = takePhoto(); progress.innerText = "Mueve ~5cm der."; takeFirstPhotoBtn.style.display = 'none'; takeSecondPhotoBtn.style.display = 'block'; };
  takeSecondPhotoBtn.onclick = () => { triggerFlash(); const secondImageData = takePhoto(); progress.innerText = "Proc..."; const img1 = new Image(); const img2 = new Image(); img1.onload = () => { img2.onload = () => { const combinedCanvas = document.createElement('canvas'); const combinedCtx = combinedCanvas.getContext('2d'); combinedCanvas.width = img1.width + img2.width; combinedCanvas.height = Math.max(img1.height, img2.height); combinedCtx.drawImage(img1, 0, 0); combinedCtx.drawImage(img2, img1.width, 0); const combinedImageURL = combinedCanvas.toDataURL('image/jpeg'); resultImage.src = combinedImageURL; resultModal.style.display = 'flex'; progress.innerText = ''; takeSecondPhotoBtn.style.display = 'none'; }; img2.src = secondImageData; }; img1.src = firstImageData; };
  closeResultModalBtn.onclick = () => { resetUI(); };
  window.onclick = (event) => { if (event.target == resultModal) { resetUI(); } };
  saveBtn.onclick = () => { const link = document.createElement('a'); link.href = resultImage.src; link.download = 'foto-3d-captura.jpg'; document.body.appendChild(link); link.click(); document.body.removeChild(link); };

  // --- Listener para el botón Fullscreen Simulado ---
  fullscreenBtn.addEventListener('click', () => {
      const elemento = imageViewer; // El elemento a "maximizar"
      if (elemento.classList.contains('fullscreen-simulated')) {
          elemento.classList.remove('fullscreen-simulated');
          fullscreenBtn.textContent = "Ampliar"; // Restaurar texto
          console.log("Saliendo de fullscreen simulado");
      } else {
          elemento.classList.add('fullscreen-simulated');
          fullscreenBtn.textContent = "Reducir"; // Cambiar texto
          console.log("Entrando a fullscreen simulado");
      }
  });

  // --- Inicializar UI al cargar ---
  resetUI();

</script>

</body>
</html>