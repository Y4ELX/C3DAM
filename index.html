<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Cámara y Visor 3D v3</title>
  <style>
    /* Reset y Estilos Base */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-user-select: none; user-select: none;
      -webkit-touch-callout: none;
    }
    html { height: -webkit-fill-available; background-color: #000; }
    body {
      height: 100dvh; min-height: -webkit-fill-available;
      overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      display: flex; flex-direction: column; background-color: #000; color: #fff;
    }
    /* --- Estilos Cámara (sin cambios) --- */
    #mainInterface { display: flex; flex-direction: column; height: 100%; width: 100%; }
    .viewport-container { position: relative; flex-grow: 1; overflow: hidden; display: flex; background-color: #000; }
    #video { width: 100%; height: 100%; object-fit: cover; display: block; z-index: 1; }
    #flashOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: white; opacity: 0; pointer-events: none; z-index: 5; display: none; }
    @keyframes flashAnimation { 0% { opacity: 0; } 50% { opacity: 0.7; } 100% { opacity: 0; } }
    #flashOverlay.flash { display: block; animation: flashAnimation 0.3s ease-in-out; }
    #controls-container { background-color: #000; padding: 15px 20px; display: flex; flex-direction: column; align-items: center; width: 100%; flex-shrink: 0; z-index: 10; position: relative; }
    #initial-buttons { display: flex; gap: 15px; margin-bottom: 10px; }
    #progress { margin-bottom: 15px; font-size: 0.9em; color: #ccc; text-align: center; min-height: 2.5em; line-height: 1.4; }
    button { background: none; border: none; color: #fff; cursor: pointer; font-size: 1em; padding: 10px 15px; border-radius: 8px; background-color: #333; transition: background-color 0.2s ease; }
    button:active { background-color: #555; }
    #startBtn, #visualizeBtn { padding: 12px 20px; font-weight: 500; }
    #takeFirstPhoto, #takeSecondPhoto { width: 70px; height: 70px; border-radius: 50%; background-color: rgba(255, 255, 255, 0.9); border: 4px solid #fff; padding: 0; margin: 10px 0; position: relative; }
    #takeFirstPhoto:active, #takeSecondPhoto:active { background-color: rgba(200, 200, 200, 0.9); }
    #canvas { display: none; } #photoPreview { display: none; } #fileInput { display: none; }
    /* --- Estilos Modal Resultado (sin cambios) --- */
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100dvh; overflow: auto; background-color: rgba(0, 0, 0, 0.8); justify-content: center; align-items: center; padding: 15px; }
    .modal-content { background-color: #282828; color: #fff; margin: auto; padding: 25px; width: auto; max-width: 90%; max-height: 90dvh; position: relative; border-radius: 12px; box-shadow: 0 8px 25px rgba(0,0,0,0.5); text-align: center; display: flex; flex-direction: column; align-items: center; }
    .modal-content img { display: block; max-width: 100%; max-height: calc(90dvh - 150px); height: auto; margin-bottom: 20px; border-radius: 6px; }
    .close-btn { color: #ccc; position: absolute; top: 10px; right: 15px; font-size: 30px; font-weight: bold; cursor: pointer; line-height: 1; z-index: 10; padding: 5px; background-color: rgba(0, 0, 0, 0.3); border-radius: 50%; }
    .close-btn:hover, .close-btn:focus { color: #fff; background-color: rgba(0, 0, 0, 0.6); }
    #saveBtn { background-color: #007AFF; color: white; padding: 12px 25px; border: none; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: bold; margin-top: 10px; }
    #saveBtn:hover { background-color: #005ecb; }

    /* --- Estilos del Visor de Imágenes (MODIFICADO) --- */
    #imageViewer {
        display: none; position: fixed; top: 0; left: 0;
        width: 100vw; height: 100dvh; background-color: #000;
        z-index: 2000; touch-action: none;
    }

    #splitViewContainer { /* Contenedor principal del visor, ahora solo usa flex */
        display: flex; /* Pone los contenedores de mitad lado a lado */
        width: 100%;
        height: 100%;
        /* Ya no necesita overflow: hidden ni position: relative */
    }

    .image-half-container { /* NUEVO: Contenedor para cada mitad */
        width: 50%;        /* Ocupa la mitad del ancho */
        height: 100%;       /* Ocupa toda la altura */
        overflow: hidden;   /* ! La clave: corta el contenido de la imagen interna ! */
        position: relative; /* ! Necesario para posicionar la imagen interna absolutamente ! */
    }

    #leftImage, #rightImage { /* La imagen DENTRO de su contenedor de mitad */
        position: absolute; /* Posicionada relativa a .image-half-container */
        top: 0;
        left: 0;
        width: 100%;  /* Ocupa el 100% del contenedor de mitad (que es 50% del total) */
        height: 100%; /* Ocupa el 100% de la altura */
        object-fit: cover; /* Ajuste de imagen */
        transform-origin: center center; /* Origen del zoom/pan */
        will-change: transform; /* Optimización */
        background-color: #111; /* Fondo por si acaso */
        /* Importante: Ya no necesitamos left: 50% para #rightImage,
           porque su contenedor (.image-half-container) ya está en la posición correcta */
    }

    /* Botón de cerrar específico del visor */
    #closeViewerBtn { /* Ya no es necesario aquí, usa .close-btn */ }

  </style>
</head>
<body>

<div id="mainInterface">
    <div class="viewport-container">
        <video id="video" autoplay muted playsinline></video>
        <div id="flashOverlay"></div>
    </div>
    <canvas id="canvas"></canvas> <div id="controls-container">
      <div id="progress"></div>
      <div id="initial-buttons">
          <button id="startBtn">Iniciar Cámara</button>
          <button id="visualizeBtn">Visualizar Fotos</button>
      </div>
      <button id="takeFirstPhoto" style="display:none;"></button>
      <button id="takeSecondPhoto" style="display:none;"></button>
    </div>
</div>

<input type="file" id="fileInput" accept="image/*">

<div id="resultModal" class="modal">
  <div class="modal-content">
    <span id="closeResultModalBtn" class="close-btn">&times;</span>
    <img id="resultImage" src="" alt="Foto 3D Generada">
    <button id="saveBtn">Guardar Foto</button>
  </div>
</div>

<div id="imageViewer">
    <div id="splitViewContainer">
        <div id="leftContainer" class="image-half-container">
            <img id="leftImage" src="" alt="Mitad Izquierda">
        </div>
        <div id="rightContainer" class="image-half-container">
            <img id="rightImage" src="" alt="Mitad Derecha">
        </div>
    </div>
    <span id="closeViewerBtn" class="close-btn">&times;</span>
</div>


<script>
  let firstImageData = null;
  let stream = null;

  // --- Elementos DOM ---
  const mainInterface = document.getElementById('mainInterface');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas'); // Canvas para tomar fotos
  const progress = document.getElementById('progress');
  const startBtn = document.getElementById('startBtn');
  const visualizeBtn = document.getElementById('visualizeBtn');
  const initialButtonsContainer = document.getElementById('initial-buttons');
  const takeFirstPhotoBtn = document.getElementById('takeFirstPhoto');
  const takeSecondPhotoBtn = document.getElementById('takeSecondPhoto');
  const controlsContainer = document.getElementById('controls-container');
  const flashOverlay = document.getElementById('flashOverlay');
  const fileInput = document.getElementById('fileInput');

  // Modal Resultado Cámara
  const resultModal = document.getElementById('resultModal');
  const resultImage = document.getElementById('resultImage');
  const closeResultModalBtn = document.getElementById('closeResultModalBtn');
  const saveBtn = document.getElementById('saveBtn');

  // Visor de Imágenes
  const imageViewer = document.getElementById('imageViewer');
  const splitViewContainer = document.getElementById('splitViewContainer');
  // No necesitamos leftContainer/rightContainer en JS si no interactuamos directamente con ellos
  const leftImage = document.getElementById('leftImage');
  const rightImage = document.getElementById('rightImage');
  const closeViewerBtn = document.getElementById('closeViewerBtn');

  // --- Estado de Zoom/Pan del Visor ---
  let currentScale = 1;
  let currentTranslateX = 0;
  let currentTranslateY = 0;
  let isPanning = false;
  let isZooming = false;
  let startX, startY, initialPinchDistance;
  let initialTranslateX = 0, initialTranslateY = 0;

  // --- Gestión de Object URLs ---
  let objectURLsToRevoke = [];

  function revokePreviousObjectURLs() {
    if (objectURLsToRevoke.length > 0) {
        console.log("Revocando", objectURLsToRevoke.length, "Object URLs anteriores.");
        objectURLsToRevoke.forEach(url => { URL.revokeObjectURL(url); });
        objectURLsToRevoke = [];
    }
  }

  // --- Funciones Cámara (sin cambios) ---
  function triggerFlash() { /* ... */ }
  flashOverlay.addEventListener('animationend', () => { /* ... */ });
  function startCamera() { /* ... */ }
  function stopCamera() { /* ... */ }
  function takePhoto() { /* ... */ }
  function requestPermissionAndStart() { startCamera(); }

  // --- Modificado resetUI para revocar URLs (sin cambios) ---
  function resetUI() {
      stopCamera();
      revokePreviousObjectURLs();
      video.style.display = 'block';
      initialButtonsContainer.style.display = 'flex';
      takeFirstPhotoBtn.style.display = 'none';
      takeSecondPhotoBtn.style.display = 'none';
      progress.innerText = '';
      resultModal.style.display = 'none';
      imageViewer.style.display = 'none';
      mainInterface.style.display = 'flex';
      controlsContainer.style.display = 'flex';
      firstImageData = null;
      flashOverlay.style.display = 'none';
      flashOverlay.classList.remove('flash');
      resetViewerState();
  }

  // --- Funciones Visor de Imágenes ---

  function resetViewerState() {
    currentScale = 1;
    currentTranslateX = 0;
    currentTranslateY = 0;
    applyTransform();
    fileInput.value = null;
  }

  // ApplyTransform sigue igual: aplica la misma tfm a ambas imágenes
  function applyTransform() {
      const transformValue = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`;
      leftImage.style.transform = transformValue;
      rightImage.style.transform = transformValue;
  }

  // --- Helper para convertir canvas a Blob con Promise (sin cambios) ---
  function canvasToBlob(canvas, mimeType = 'image/jpeg', quality = 0.85) {
    return new Promise((resolve, reject) => {
        if (!canvas.toBlob) { reject(new Error("Canvas.toBlob() no soportado")); return; }
        canvas.toBlob(blob => {
            if (blob) { resolve(blob); }
            else { reject(new Error("canvas.toBlob() falló (canvas vacío?)")); }
        }, mimeType, quality);
    });
  }


  // --- handleFileSelect (Split con Object URL / toBlob - SIN CAMBIOS EN JS) ---
  // La versión anterior que funcionaba para mostrar la imagen ya hace el split
  // y usa Object URLs. La corrección es puramente estructural (HTML/CSS).
  async function handleFileSelect(event) {
    console.log("handleFileSelect llamado (Split con Object URL)");
    const file = event.target.files[0];
    if (!file || !file.type.startsWith('image/')) {
        alert('Por favor, selecciona un archivo de imagen.');
        resetUI(); return;
    }
    console.log("Archivo seleccionado:", file.name, file.type);

    revokePreviousObjectURLs();

    let originalFileURL = null;
    try {
        originalFileURL = URL.createObjectURL(file);
        objectURLsToRevoke.push(originalFileURL);
        console.log("Original File Object URL creado");
    } catch (error) {
        console.error("Error creando Object URL para el archivo original:", error);
        alert("Error al crear URL para el archivo.");
        resetUI(); return;
    }

    const img = new Image();
    img.onload = async () => {
        console.log("Image onload. Dimensiones:", img.naturalWidth, "x", img.naturalHeight);
        if (img.naturalWidth <= 0 || img.naturalHeight <= 0) { alert("Dimensiones inválidas."); resetUI(); return; }
        if (img.naturalWidth < 2) { alert("Imagen demasiado estrecha."); resetUI(); return; }

        try {
            const canvasLeft = document.createElement('canvas');
            const ctxLeft = canvasLeft.getContext('2d');
            const leftWidth = Math.floor(img.naturalWidth / 2);
            const height = img.naturalHeight;
            canvasLeft.width = leftWidth; canvasLeft.height = height;
            console.log("Dibujando mitad izquierda...");
            ctxLeft.drawImage(img, 0, 0, leftWidth, height, 0, 0, leftWidth, height);

            const canvasRight = document.createElement('canvas');
            const ctxRight = canvasRight.getContext('2d');
            const rightWidth = img.naturalWidth - leftWidth;
            const sourceXRight = leftWidth;
            canvasRight.width = rightWidth; canvasRight.height = height;
            console.log("Dibujando mitad derecha...");
            ctxRight.drawImage(img, sourceXRight, 0, rightWidth, height, 0, 0, rightWidth, height);

            console.log("Convirtiendo ambos canvas a Blobs (JPEG)...");
            const [blobLeft, blobRight] = await Promise.all([
                canvasToBlob(canvasLeft, 'image/jpeg', 0.85),
                canvasToBlob(canvasRight, 'image/jpeg', 0.85)
            ]);
            console.log("Blobs generados.");

            let leftBlobURL = null; let rightBlobURL = null;
            try {
                leftBlobURL = URL.createObjectURL(blobLeft);
                objectURLsToRevoke.push(leftBlobURL);
                rightBlobURL = URL.createObjectURL(blobRight);
                objectURLsToRevoke.push(rightBlobURL);
                console.log("Object URLs de Blobs creados.");
            } catch (error) {
                 console.error("Error creando Object URLs desde Blobs:", error);
                 alert("Error al crear URLs para las imágenes procesadas.");
                 resetUI(); return;
            }

            console.log("Asignando Object URLs a las imágenes del visor...");
            leftImage.src = leftBlobURL;
            rightImage.src = rightBlobURL;

            console.log("Mostrando el visor...");
            resetViewerState();
            imageViewer.style.display = 'block';
            mainInterface.style.display = 'none';

        } catch (error) {
            console.error("Error durante el procesamiento y división:", error);
            alert("Error al procesar la imagen: " + error.message);
            resetUI();
        }
    }; // Fin img.onload

    img.onerror = function(e) {
        console.error("Image onerror al cargar desde:", originalFileURL ? originalFileURL.substring(0,100) : "URL inválida");
        alert('Error: No se pudo cargar la imagen fuente seleccionada desde Object URL.');
        resetUI();
    };
    console.log("Asignando Object URL del archivo original a img.src");
    img.src = originalFileURL;
}
  // --- FIN handleFileSelect ---


  // --- Manejo Táctil del Visor (Sin cambios en la lógica de cálculo) ---
  function getDistance(touches) { /* ... */ }
  function getMidpoint(touches) { /* ... */ }
  splitViewContainer.addEventListener('touchstart', (e) => { /* ... */ }, { passive: false });
  splitViewContainer.addEventListener('touchmove', (e) => { /* ... */ }, { passive: false });
  splitViewContainer.addEventListener('touchend', (e) => { /* ... */ });


  // --- Event Listeners Botones (Sin cambios) ---
  startBtn.onclick = requestPermissionAndStart;
  visualizeBtn.onclick = () => fileInput.click();
  fileInput.onchange = handleFileSelect;
  closeViewerBtn.onclick = resetUI;
  takeFirstPhotoBtn.onclick = () => { /* ... */ };
  takeSecondPhotoBtn.onclick = () => { /* ... */ };
  closeResultModalBtn.onclick = () => { resetUI(); };
  window.onclick = (event) => { if (event.target == resultModal) { resetUI(); } };
  saveBtn.onclick = () => { /* ... */ };

  // --- Inicializar UI al cargar ---
  resetUI();

// --- Código JS sin cambios se omite por brevedad (...) ---
// Pegar aquí las implementaciones completas de las funciones omitidas si es necesario
// (getDistance, getMidpoint, touchstart, touchmove, touchend, triggerFlash, startCamera, etc.)
// El código anterior YA las incluía, así que deberían estar bien.

</script>

</body>
</html>